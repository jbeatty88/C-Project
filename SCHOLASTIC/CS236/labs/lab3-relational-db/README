A relational database management system (RDBMS) maintains data sets called relations. A relation has a name, a schema, and a set of tuples. A schema is a set of attributes. A tuple is a set of attribute/value pairs. An attribute is the name associated with each data value in a tuple entry. Relations are used as operands in relational operations such as rename, selection, projection, union, and join. The goal of this project is to build a relational database system from a Datalog file, and then answer queries using relational algebra.
***********PROJECT DESCRIPTION******************


A Datalog Program can be represented by a Database. Each scheme in a Datalog Program defines a relation in the Database. The scheme defines the name of the relation, and the attribute list of the scheme defines the schema of the relation. Each fact in the Datalog Program defines a tuple in a relation. The fact name identifies a relation to which the tuple belongs. The basic data structure is a database consisting of relations, each with their own name, schema, and set of tuples. How you choose and use your data structures effects the difficulty of the project. Inheritance and polymorphism are always useful. Each data structure implementation has its benefits, drawbacks and obstacles to overcome.

Your program must convert every Datalog query into a sequence of select, project, and rename operations. As you prepare to write your program, take out a piece of paper, convert each of the queries in the given examples into a relational expression, and carry out these expressions. Your program should create these same expressions.

************ REQUIREMENTS *****************


The project is divided into two parts representing different aspects of the final solution: part 1 implements a relation class and how it is used to answer queries and part 2 connects the relation class to the datalog program object created by the parser.
Part 1: relation class with tests

Create a relation object that includes methods implementing select, project, and rename operations. The relation and its methods must follow the mathematical definitions described in class and in the textbook. For example, the operators must not produce relations which have duplicate tuples or duplicate names in the schema.

Implement at least 10 tests to validate the select, project, and rename methods:

    At least 4 of the 10 tests must mimic a datalog query in that they use a sequence of select, project, and rename to answer the query (as explained below in the FAQ).
    The tests must be testing either a select, project, rename, or a query; they may not test if the relation you create is structured properly (i.e. proper sorting, no duplicates, etc.; while these things are important, they are not what should be tested).
        Both types of selects must be implemented.
    The tests must be documented and justified: what does the test accomplish?
        Each test must be marked with comments explaining what operation is being performed and why.
        For the 4 tests that mimic a query, the comments must include the actual query that is being mimicked.
    Each of the tests must test something different; if one test case tests the same thing as another, it isn't telling you anything new, and therefore it won't be counted as one of the 10 tests.

Further, all the tests must be automatic; automatic means the tests run without any user input and reports to the console the status of every test: pass or fail.

    Command line: no command line arguments
    Output: A pass/fail report for each test. (see below for further details on these tests)

The only text that needs to be outputted to the console is the test number and whether it passed or not (but you may definitely output more!). The TAs will look at your code to make sure the test cases do what you say they are doing in the comments. They will also make sure you implemented the select, project, and rename functions.

For this project, each test case you create should pass. The pass/fail report of a test is based on a comparison between the expected result and the actual result of each test. The comparison must be made automatically by your tester. This means that your tester must have the expected output in the code to compare with the actual output in an if-else statement; the actual output is the relation that is created after performing the select, project, and/or rename operations, while the expected output is what you calculate the relation should be after performing the operations. Common ways to check if they are equal include creating a method that tests if two relations have the same name, schema, and tuples; or creating a toString function for the relation class and comparing the strings for each relation. It is up to you how to do this, but what is not allowed is always outputting that each test passed without actually checking that the code does what it is supposed to do.

The pass-off is based on the quality of tests and whether or not the solution passes. If a test does not automatically compare actual and expected out as described above, it won't be counted. If more than one test case tests the same thing, only the first test case will be counted.
Part 2: RDBMS-based Interpreter

Write an RDBMS-based interpreter for a Datalog Program. Given a Datalog Program object from the datalog parser, your interpreter should create an instance of a database object holding relations and then compute and print the result for each query using only the facts form the input (interpretation of the rules will be added in Project 4). Your design should include a class for the database and use your relation from part 1. Queries must be implemented by performing the appropriate relational operations as in the tests from part 1 (select, project, and rename). As a reminder, use the datalog object from the parser to initialize the database object, and then interpret the queries in that same object to generate the output. Queries should become a series of select, rename, and project calls on one of the relations in the database.

To format the output for pass-off, you must make it look like the examples below. Note the following: The queries are to be evaluated in the order listed in the Datalog Program. For each query, print the query and a space. Then, if the query's resulting relation is empty, output “No”; and if the resulting relation is not empty, output “Yes(n)” where n is the number of tuples in the resulting relation. If there are free variables in the query, print the tuples of the resulting relation, one per line and indented by two spaces, according to the following directions. Each tuple should be a comma-space separated list of pairs–(variable, string-value)–ordered according to the order of variable appearance in the query. The format of a pair is v= 's', where v is the variable and 's' is the string value. Sort the tuples alphabetically based on string values in the tuples' variables (sort with the first sort key as the first variable (in order of appearance in the query), the second sort key as the second variable, and so on).

The focus of this project is on interpreting 236-Datalog (without rules)–not on building an industrial-strength interpreter. Thus, to retain the central focus and keep the amount of coding within a reasonable bound, you may assume:

    The arity (number of parameters) of all schemes, facts, rules and queries that have the same name are guaranteed to match. You do not have to check for matching arity.
    No two attributes in the same scheme will have the same name. You do not have to check for this.
    No two schemes in the scheme list will have the same name. You do not have to check for this.
    Every scheme (or relation) referenced in a fact, rule head, predicate, or query will have been defined in the scheme section.

Interface requirements:

    Command line: a single argument indicating the input file
    Input: a valid datalog program
    Output: see the output specifications and examples

Part 2 is scored on a set of 10 private tests at submission.
